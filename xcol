#!/usr/bin/perl
use 5.014 ; use strict ; use warnings ;
use Getopt::Std ; getopts "aAe:E:ik:K:mr=,:0" , \my%o ;

# $o{','} ; # 入出力の区切り文字
my $outStr ; ## 出力の仕方を表す、"無名関数"
my %M   ; # 変換テーブル
my $fn  ; # 入力のファイル名。逐次処理される。
my $noinput ; # 入力そのものが無かったことを表す文字列
my $notfound ; # 変換先が見つからなかったことを示す文字列
my $result0 ; # ヘッダ行の変換結果

&choreArgs ; &readMapFile ; &procMain ;
exit 0 ;

sub choreArgs {
	$notfound = ( $o{e} //= 'notfound' ) ;
  $noinput = ( $o{E} //= 'noinput' ) ;
	$o{','} //= "\t" ;
	$o{k} = ( $o{k} //= 1 ) > 0 ? $o{k} -1 : $o{k} ;
	$o{K} //= 1 ;
  $o{r} = $o{r} ? 1 : 0 ;
	$fn = shift @ARGV ;
	&HELP_MESSAGE unless defined $fn ;
	$outStr = $o{A} ? \&out_A : $o{a} ? \&out_a : $o{i} ? \&out_i : \&out_n ;
}

sub out_n ($@) { shift @_ } ; # 変換結果だけを出力する。
sub out_i ($@) { my $r=shift @_ ; splice @_,$o{k},0,$r ; join $o{','} , @_ } ; # 元にあった場所に置き換えて出力
sub out_a ($@) { my $r=shift @_ ; join $o{','} , $r, $_ } ; # 変換結果を、元の入力行の先頭に付加。
sub out_A ($@) { my $r=shift @_ ; join $o{','} , $_, $r } ; # 変換結果を、元の入力行の末尾に付加。

# 参照表ファイルの読取り
sub readMapFile {
	open my $mh , "<" , $fn or die "File `$fn' does not open. " , $! ;
	my ($from,$to) = $o{r} ? (1,0) : (0,1) ; # 変換方向の指定。
	while ( <$mh> ) {
		chomp ;
		my @F = split /$o{','}/ , $_ , -1 ; # 2を指定では無いようにした。
		next if @F < $o{K} ; # 列の数が足りないならば読み飛ばす。
		my $key = join $o{','} , splice @F , -$o{r} * $o{K} , $o{K}   ; # -r 指定なら末尾の1列、未指定なら、先頭から1列をキーとする。
    my $value = join $o{','} , @F ;
    $M{ $key } = $o{m} ? $M{ $key } + 1 : $value ; # -m 指定であれば、変換時の多重度のチェックになる。
    $result0 = $value unless defined $result0 ; # 無駄に分岐をした可能性がある。
	}
	close $mh ;
}

# 変換対象の入力を読取り、処理をする。
sub procMain {
	if ( $o{'='} ) {
		$_ = <> ;
		chomp  ;
		my @F = split /$o{','}/ , $_ , -1 ; #
		print $outStr -> ( $result0 , @F ) , "\n"   ;
	}
	while ( <> ) {
		chomp ;
		my @F = split /$o{','}/ , $_ , -1 ; # 高速化のために -1 の値は工夫した方が良いかも知れない。
    my $ikey = join $o{','} , splice @F , $o{k} , $o{K} ;
    next if $o{0} and ! defined $ikey || ! defined $M{$ikey} ; # -0 指定がある場合は、読み飛ばす。
    my $result = defined $ikey ? $M{$ikey} // $notfound : $noinput  ;
		print $outStr -> ( $result , @F ) , "\n"   ;
	}
}

# ヘルプの表示
sub VERSION_MESSAGE {}
sub HELP_MESSAGE{
    $0=~s|.*/|| ; $ARGV[1] //= '' ;
    while(<DATA>){
        s/\$0/$0/g ;
        print $_ if $ARGV[1] =~ /opt/ ? m/^\ +\-/ : s/^=head1// .. s/^=cut// ;
    }
    exit 0 ;
}
__END__

=encoding utf8

=head1

 $0 table < data
 $0 table data
 cat data | $0 -k1 -K1 table

  data の指定列(k列目もしくはk列目からK個の列)を、table に従って変換したものを出力する。

  tableのファイルの中身は、タブ区切り(変更可)で1〜K列目とそれ以降が
  それぞれ、変換前の文字列、変換後の文字列で構成されているとする。
  k は -k のオプションで指定される。未指定なら1である。
  K は -K のオプションで指定される。未指定なら1である。


 オプション :

  -k num : (小文字のk) 1始まりもしくは-1終わりで列の番号を指定する。未指定なら1。
  -K num : (大文字のK) 指定位置から何列をキーにするかを指定。未指定なら1。
  -m  : 変換すべきdata の変換方法が、参照表 table によって何通り指定されているかを出力。
  -r  : 変換の仕方を逆方向にする。-Kで指定された数をKとすると、tableの末尾のK列をキーと見なす。

  -a  : 変換したものを先頭の列、変換前のデータ全体を後ろに付ける。
  -A  : 変換前のデータ全体の、次の列に変換したものを載せる。
  -i  : 入力データに対して、変換対象データを置換をする。
  -0  : 変換対象が無い場合と変換対象のキーの列が無い場合は、出力をしない。

  -=  : data の最初の行をヘッダ行と見なし、適切に結合した結果の表示をするようにする。(!要推敲)
  -, str : dataもtableも各列は、文字列strで区切られているとする。
  -e str : 変換が未定義の場合の出力文字列の指定。デフォルトは "notfound" の8文字。
  -E str : 入力が未定義の場合の出力文字列の指定。デフォルトは "noinput" の7文字。

=cut
