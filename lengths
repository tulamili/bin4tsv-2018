#!/usr/bin/perl 
use 5.010 ; use strict ; use warnings ; 
use Getopt::Std ; getopts 'lLtu=' , \my%o ;
use Encode qw/decode_utf8/ ; 

print (my $tmp=<>) if $o{'='} ; 
$o{l} || $o{L} ?  &procEachWholeLine : &procAsTSV ; 
exit 0 ; 

# Functions 

sub procEachWholeLine { 
    while (  <>  ) { 
        chomp if $o{l}  ; 
        $_ = decode_utf8 $_ if $o{u}  ;
        print length ( $_ ) , "\n" ; 
    }
}

sub procAsTSV {
    while ( <> ) {
        chomp ;
        $_ = decode_utf8 $_  if $o{u} ; 
        my @fld = split /\t/, $_ , -1 ; 
        @fld = $o{t} ? ( scalar @fld )  : map { length  } @fld ; 
        print join ("\t", @fld ) , "\n" ; 
    }
}

sub VERSION_MESSAGE { 
}

sub HELP_MESSAGE { 
    $0 =~ s/.*\/// ; 
    while ( <DATA> ) {
        s/\$0/$0/g ; 
        print $_ if s/^=head1// .. s/^=cut// ; 
    }
    exit 0 
}
__END__ 

=encoding utf8 

=head1

 $0 

 入力データを各行をタブ毎に区切って、文字の長さに変換して出力する。
 行末の改行文字は長さ計算の対象ではない。

オプション :

  -=   :  一行目を(ヘッダと見なして)そのまま出力する。
  -u   :  utf-8 とみなして、長さを計算する。そうでなければ、単純なバイト長になる。
  -t   :  単純に各行の、タブの数を数える。
  -l   :  各行の長さを算出する。行末の改行文字を含めない。-t は無効化される。
  -L   :  各行の長さを算出する。行末の改行文字も含める。 -t は無効化される。
ヒント: 


  $0 -= some.tsv | colsummary.pl -= とすると、長さの分布が得られる。

=cut
